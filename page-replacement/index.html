<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page Replacement Algorithm Visualization</title>
    <style>
     body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    padding: 20px;
    max-width: 1000px;
    margin: 0 auto;
    background-color: #0d1117;
    color: #e6edf3;
}

h1, h2, h3 {
    color: #58a6ff;
    text-align: center;
}

.container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin-bottom: 30px;
}

.controls {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
    margin-bottom: 20px;
    padding: 15px;
    background-color: #161b22;
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    border: 1px solid #30363d;
}

.control-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

label {
    font-weight: bold;
    margin-bottom: 5px;
    color: #8b949e;
}

select, input, button {
    padding: 8px 12px;
    border-radius: 4px;
    border: 1px solid #30363d;
    background-color: #0d1117;
    color: #e6edf3;
}

select:focus, input:focus {
    outline: none;
    border-color: #1f6feb;
    box-shadow: 0 0 0 2px rgba(56, 139, 253, 0.25);
}

button {
    background-color: #1f6feb;
    color: white;
    border: none;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.3s, transform 0.2s;
}

button:hover {
    background-color: #2f81f7;
    transform: translateY(-2px);
}

button:disabled {
    background-color: #2d333b;
    cursor: not-allowed;
    transform: none;
}

#reference-string {
    width: 100%;
    padding: 8px;
}

.visualization {
    background-color: #161b22;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    border: 1px solid #30363d;
}

.frame-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.reference-display {
    display: flex;
    overflow-x: auto;
    padding-bottom: 10px;
    margin-bottom: 20px;
    scrollbar-width: thin;
    scrollbar-color: #1f6feb #0d1117;
}

.reference-display::-webkit-scrollbar {
    height: 8px;
}

.reference-display::-webkit-scrollbar-track {
    background: #0d1117;
    border-radius: 4px;
}

.reference-display::-webkit-scrollbar-thumb {
    background-color: #1f6feb;
    border-radius: 4px;
}

.reference-cell {
    flex: 0 0 40px;
    height: 40px;
    border: 1px solid #30363d;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #0d1117;
    font-weight: bold;
    color: #e6edf3;
}

.reference-cell.current {
    background-color: #1f6feb;
    color: white;
    border-color: #388bfd;
    box-shadow: 0 0 10px rgba(31, 111, 235, 0.7);
}

.frames {
    display: flex;
    overflow-x: auto;
    scrollbar-width: thin;
    scrollbar-color: #1f6feb #0d1117;
}

.frames::-webkit-scrollbar {
    height: 8px;
}

.frames::-webkit-scrollbar-track {
    background: #0d1117;
    border-radius: 4px;
}

.frames::-webkit-scrollbar-thumb {
    background-color: #1f6feb;
    border-radius: 4px;
}

.frame-column {
    display: flex;
    flex-direction: column;
    min-width: 40px;
    border-right: 1px solid #30363d;
}

.frame-cell {
    height: 40px;
    width: 40px;
    border: 1px solid #30363d;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #0d1117;
    color: #e6edf3;
}

.counter-display {
    display: flex;
    overflow-x: auto;
    margin-top: 10px;
    margin-bottom: 20px;
    scrollbar-width: thin;
    scrollbar-color: #1f6feb #0d1117;
}

.counter-display::-webkit-scrollbar {
    height: 8px;
}

.counter-display::-webkit-scrollbar-track {
    background: #0d1117;
    border-radius: 4px;
}

.counter-display::-webkit-scrollbar-thumb {
    background-color: #1f6feb;
    border-radius: 4px;
}

.counter-column {
    display: flex;
    flex-direction: column;
    min-width: 40px;
    border-right: 1px solid #30363d;
}

.counter-cell {
    height: 30px;
    width: 40px;
    border: 1px solid #30363d;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #0d1117;
    font-size: 0.8rem;
    color: #e6edf3;
}

.results {
    margin-top: 20px;
    padding: 15px;
    background-color: #0d419d;
    border-radius: 8px;
    border: 1px solid #1f6feb;
    color: #e6edf3;
}

.algorithm-info {
    margin-top: 20px;
    padding: 15px;
    background-color: #1c2535;
    border-radius: 8px;
    border: 1px solid #244675;
}

.step-buttons {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin: 15px 0;
}

.legend {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 15px;
    margin: 20px 0;
    background-color: #1c2535;
    padding: 12px;
    border-radius: 8px;
    border: 1px solid #244675;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
}

.legend-text {
    font-weight: bold;
}

.tabs {
    display: flex;
    gap: 5px;
    margin-bottom: 15px;
}

.tab {
    padding: 10px 15px;
    background-color: #1c2535;
    cursor: pointer;
    border-radius: 5px 5px 0 0;
    border: 1px solid #30363d;
    border-bottom: none;
    color: #8b949e;
    transition: background-color 0.3s;
}

.tab:hover {
    background-color: #21293b;
}

.tab.active {
    background-color: #1f6feb;
    font-weight: bold;
    color: #ffffff;
}

.tab-content {
    border: 1px solid #30363d;
    padding: 15px;
    background-color: #161b22;
    border-radius: 0 5px 5px 5px;
}

/* Cell status indicators */
.frame-cell.page-fault:after {
    content: "(F)";
    font-size: 0.7rem;
    position: absolute;
    top: 2px;
    right: 2px;
}

.frame-cell.accessed:after {
    content: "(A)";
    font-size: 0.7rem;
    position: absolute;
    bottom: 2px;
    right: 2px;
}

.frame-cell.victim:after {
    content: "(V)";
    font-size: 0.7rem;
    position: absolute;
    bottom: 2px;
    left: 2px;
}

.frame-cell {
    position: relative;
}
    </style>
</head>
<body>
    <h1>Page Replacement Algorithm Visualization</h1>
    
    <div class="container">
        <div class="controls">
            <div class="control-group">
                <label for="algorithm">Algorithm:</label>
                <select id="algorithm">
                    <option value="fifo">FIFO (First-In-First-Out)</option>
                    <option value="lru">LRU (Least Recently Used)</option>
                    <option value="optimal">Optimal</option>
                    <option value="lfu">LFU (Least Frequently Used)</option>
                    <option value="mfu">MFU (Most Frequently Used)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="frames">Number of Frames:</label>
                <input type="number" id="frames" min="1" max="10" value="3">
            </div>
            
            <div class="control-group">
                <label for="reference-string">Reference String:</label>
                <input type="text" id="reference-string" value="7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1">
            </div>
            
            <div class="control-group">
                <button id="start">Start Visualization</button>
                <button id="reset" disabled>Reset</button>
            </div>
        </div>
        
        <div class="step-buttons">
            <button id="prev-step" disabled>Previous Step</button>
            <button id="next-step" disabled>Next Step</button>
            <button id="auto-play" disabled>Auto Play</button>
        </div>
        
    
        
        <div class="tabs">
            <div class="tab active" data-tab="visualization">Visualization</div>
            <div class="tab" data-tab="algorithm-info">Algorithm Info</div>
        </div>
        
        <div class="tab-content" id="visualization-tab">
            <div class="visualization">
                <h2>Page Reference Sequence</h2>
                <div class="reference-display" id="reference-display"></div>
                
                <h2>Memory Frames</h2>
                <div class="frame-container">
                    <div class="frames" id="frames-display"></div>
                </div>
                
                <div id="counter-section" style="display: none;">
                    <h3>Page Counters</h3>
                    <div class="counter-display" id="counter-display"></div>
                </div>
                
                <div class="results" id="results">
                    <p>Press "Start Visualization" to begin...</p>
                </div>
            </div>
        </div>
        
        <div class="tab-content" id="algorithm-info-tab" style="display:none;">
            <div class="algorithm-info">
                <h2>Page Replacement Algorithms</h2>
                
                <h3>FIFO (First-In-First-Out)</h3>
                <p>The simplest page replacement algorithm that replaces the oldest page in memory. It maintains a queue of pages, where the oldest page is at the front of the queue.</p>
                <p><strong>Advantage:</strong> Simple to implement and understand.</p>
                <p><strong>Disadvantage:</strong> Does not consider page usage frequency, leading to potential replacement of frequently used pages.</p>
                
                <h3>LRU (Least Recently Used)</h3>
                <p>Replaces the page that has not been used for the longest period of time. It keeps track of when each page was last accessed.</p>
                <p><strong>Advantage:</strong> Better performance than FIFO as it considers temporal locality.</p>
                <p><strong>Disadvantage:</strong> Requires additional overhead to track page usage history.</p>
                
                <h3>Optimal</h3>
                <p>Replaces the page that will not be used for the longest period of time in the future. This is a theoretical algorithm that requires future knowledge of page references.</p>
                <p><strong>Advantage:</strong> Provides the lowest possible page fault rate, serves as a benchmark.</p>
                <p><strong>Disadvantage:</strong> Not practically implementable in real systems as it requires knowledge of future references.</p>
                
                <h3>LFU (Least Frequently Used)</h3>
                <p>Replaces the page that has been used least frequently. It keeps a counter for each page and increments it on each access.</p>
                <p><strong>Advantage:</strong> Can perform better than LRU when access patterns have cyclical behavior.</p>
                <p><strong>Disadvantage:</strong> May keep pages with high historical frequency but no recent usage, leading to potential thrashing.</p>
                
                <h3>MFU (Most Frequently Used)</h3>
                <p>Replaces the page that has been used most frequently. Based on the logic that pages with high frequency counter values have completed their use and won't be used again soon.</p>
                <p><strong>Advantage:</strong> Can work well in certain specialized workloads.</p>
                <p><strong>Disadvantage:</strong> Generally performs worse than LFU and LRU in most common scenarios.</p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM Elements
            const algorithmSelect = document.getElementById('algorithm');
            const framesInput = document.getElementById('frames');
            const referenceStringInput = document.getElementById('reference-string');
            const startButton = document.getElementById('start');
            const resetButton = document.getElementById('reset');
            const prevStepButton = document.getElementById('prev-step');
            const nextStepButton = document.getElementById('next-step');
            const autoPlayButton = document.getElementById('auto-play');
            const referenceDisplay = document.getElementById('reference-display');
            const framesDisplay = document.getElementById('frames-display');
            const counterSection = document.getElementById('counter-section');
            const counterDisplay = document.getElementById('counter-display');
            const resultsDiv = document.getElementById('results');
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            
            // Variables
            let referenceString = [];
            let frames = [];
            let counters = {}; // For LFU and MFU
            let currentStep = -1;
            let pageFaults = 0;
            let pageHits = 0;
            let history = [];
            let autoPlayInterval;
            let isAutoPlaying = false;
            
            // Track page load order for FIFO algorithm
            let pageLoadOrder = [];
            
            // Initialize
            function init() {
                algorithmSelect.disabled = false;
                framesInput.disabled = false;
                referenceStringInput.disabled = false;
                startButton.disabled = false;
                resetButton.disabled = true;
                prevStepButton.disabled = true;
                nextStepButton.disabled = true;
                autoPlayButton.disabled = true;
                
                referenceDisplay.innerHTML = '';
                framesDisplay.innerHTML = '';
                counterDisplay.innerHTML = '';
                counterSection.style.display = 'none';
                resultsDiv.innerHTML = '<p>Press "Start Visualization" to begin...</p>';
                
                referenceString = [];
                frames = [];
                counters = {};
                pageLoadOrder = [];
                currentStep = -1;
                pageFaults = 0;
                pageHits = 0;
                history = [];
                
                clearInterval(autoPlayInterval);
                isAutoPlaying = false;
                autoPlayButton.textContent = 'Auto Play';
            }
            
            // Start visualization
            startButton.addEventListener('click', function() {
                // Parse reference string
                referenceString = referenceStringInput.value
                    .trim()
                    .split(/\s+/)
                    .map(n => parseInt(n));
                
                // Validate reference string
                if (referenceString.some(isNaN)) {
                    alert('Invalid reference string. Please enter space-separated numbers.');
                    return;
                }
                
                // Get number of frames
                const numFrames = parseInt(framesInput.value);
                if (isNaN(numFrames) || numFrames < 1 || numFrames > 10) {
                    alert('Number of frames must be between 1 and 10.');
                    return;
                }
                
                // Initialize frames
                frames = Array(numFrames).fill(null);
                
                // Initialize counters for each possible page in reference string
                const uniquePages = new Set(referenceString);
                uniquePages.forEach(page => {
                    counters[page] = 0;
                });
                
                // Reset page load order
                pageLoadOrder = [];
                
                // Show counter section for LFU and MFU
                const isFrequencyBased = ['lfu', 'mfu'].includes(algorithmSelect.value);
                counterSection.style.display = isFrequencyBased ? 'block' : 'none';
                
                // Update UI
                algorithmSelect.disabled = true;
                framesInput.disabled = true;
                referenceStringInput.disabled = true;
                startButton.disabled = true;
                resetButton.disabled = false;
                nextStepButton.disabled = false;
                autoPlayButton.disabled = false;
                
                // Initialize visualization
                renderReferenceString();
                renderFrames();
                if (isFrequencyBased) {
                    renderCounters();
                }
                currentStep = -1;
                pageFaults = 0;
                pageHits = 0;
                history = [{ 
                    frames: [...frames], 
                    counters: {...counters},
                    pageFault: false, 
                    victim: null, 
                    accessed: null,
                    pageLoadOrder: [...pageLoadOrder]
                }];
                
                updateResults();
            });
            
            // Reset visualization
            resetButton.addEventListener('click', init);
            
            // Next step
            nextStepButton.addEventListener('click', nextStep);
            
            // Previous step
            prevStepButton.addEventListener('click', prevStep);
            
            // Auto play
            autoPlayButton.addEventListener('click', function() {
                if (isAutoPlaying) {
                    clearInterval(autoPlayInterval);
                    isAutoPlaying = false;
                    autoPlayButton.textContent = 'Auto Play';
                } else {
                    isAutoPlaying = true;
                    autoPlayButton.textContent = 'Stop';
                    autoPlayInterval = setInterval(() => {
                        if (currentStep >= referenceString.length - 1) {
                            clearInterval(autoPlayInterval);
                            isAutoPlaying = false;
                            autoPlayButton.textContent = 'Auto Play';
                            return;
                        }
                        nextStep();
                    }, 800);
                }
            });
            
            // Tab switching
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    // Remove active class from all tabs
                    tabs.forEach(t => t.classList.remove('active'));
                    // Add active class to clicked tab
                    this.classList.add('active');
                    
                    // Hide all tab contents
                    tabContents.forEach(content => content.style.display = 'none');
                    // Show selected tab content
                    document.getElementById(`${this.dataset.tab}-tab`).style.display = 'block';
                });
            });
            
            // Render reference string
            function renderReferenceString() {
                referenceDisplay.innerHTML = '';
                
                referenceString.forEach((page, index) => {
                    const cell = document.createElement('div');
                    cell.className = 'reference-cell';
                    cell.id = `ref-${index}`;
                    cell.textContent = page;
                    referenceDisplay.appendChild(cell);
                });
            }
            function renderFrames() {
    framesDisplay.innerHTML = '';
    
    // Create initial column for frame numbers
    const frameNumberColumn = document.createElement('div');
    frameNumberColumn.className = 'frame-column';
    
    for (let i = 0; i < frames.length; i++) {
        const cell = document.createElement('div');
        cell.className = 'frame-cell';
        cell.textContent = `F${i}`;
        cell.style.fontWeight = 'bold';
        cell.style.backgroundColor = '#2d333b';
        frameNumberColumn.appendChild(cell);
    }
    
    framesDisplay.appendChild(frameNumberColumn);
    
    // Create a column for each step in history
    for (let i = 0; i <= currentStep + 1; i++) {
        if (i >= history.length) continue;
        
        const state = history[i];
        const column = document.createElement('div');
        column.className = 'frame-column';
        column.id = `step-${i}`;
        
        for (let j = 0; j < frames.length; j++) {
            const cell = document.createElement('div');
            cell.className = 'frame-cell';
            
            // Set content
            if (state.frames[j] !== null) {
                cell.textContent = state.frames[j];
            }
            
            column.appendChild(cell);
        }
        
        framesDisplay.appendChild(column);
    }
}
            function renderCounters() {
                counterDisplay.innerHTML = '';
                
                // Create initial column for page numbers
                const pageNumberColumn = document.createElement('div');
                pageNumberColumn.className = 'counter-column';
                
                // Add a cell for each possible page
                for (const page in counters) {
                    const cell = document.createElement('div');
                    cell.className = 'counter-cell';
                    cell.textContent = `Page ${page}`;
                    cell.style.fontWeight = 'bold';
                    cell.style.backgroundColor = '#2d333b';
                    pageNumberColumn.appendChild(cell);
                }
                
                counterDisplay.appendChild(pageNumberColumn);
                
                // Create a column for each step in history
                for (let i = 0; i <= currentStep + 1; i++) {
                    if (i >= history.length) continue;
                    
                    const state = history[i];
                    const column = document.createElement('div');
                    column.className = 'counter-column';
                    column.id = `counter-step-${i}`;
                    
                    // Add a cell for each page counter
                    for (const page in state.counters) {
                        const cell = document.createElement('div');
                        cell.className = 'counter-cell';
                        cell.textContent = state.counters[page];
                        
                        // Highlight the accessed page in this step
                        if (i > 0 && parseInt(page) === state.accessed) {
                            cell.classList.add('accessed');
                        }
                        
                        column.appendChild(cell);
                    }
                    
                    counterDisplay.appendChild(column);
                }
            }
            
            // Update results display
            function updateResults() {
                if (currentStep < 0) {
                    resultsDiv.innerHTML = '<p>Press "Next Step" to begin...</p>';
                    return;
                }
                
                const totalSteps = currentStep + 1;
                const faultRate = totalSteps > 0 ? (pageFaults / totalSteps * 100).toFixed(2) : 0;
                const hitRate = totalSteps > 0 ? (pageHits / totalSteps * 100).toFixed(2) : 0;
                
                resultsDiv.innerHTML = `
                    <p><strong>Current step:</strong> ${currentStep + 1} of ${referenceString.length}</p>
                    <p><strong>Page faults:</strong> ${pageFaults} (${faultRate}%)</p>
                    <p><strong>Page hits:</strong> ${pageHits} (${hitRate}%)</p>
                `;
                
                // Update reference string highlighting
                document.querySelectorAll('.reference-cell').forEach(cell => cell.classList.remove('current'));
                if (currentStep >= 0 && currentStep < referenceString.length) {
                    document.getElementById(`ref-${currentStep}`).classList.add('current');
                }
            }
            
            // Next step logic
            function nextStep() {
                if (currentStep >= referenceString.length - 1) return;
                
                currentStep++;
                const page = referenceString[currentStep];
                
                // Check if page is already in frames
                const frameIndex = frames.indexOf(page);
                let pageFault = false;
                let victim = null;
                
                if (frameIndex === -1) {
                    // Page fault
                    pageFault = true;
                    pageFaults++;
                    
                    // Find frame to replace based on algorithm
                    let replaceIndex;
                    
                    if (frames.includes(null)) {
                        // There's an empty frame
                        replaceIndex = frames.indexOf(null);
                    } else {
                        // Need to replace a page
                        switch (algorithmSelect.value) {
                            case 'fifo':
                                replaceIndex = getFIFOReplacement();
                                break;
                            case 'lru':
                                replaceIndex = getLRUReplacement();
                                break;
                            case 'optimal':
                                replaceIndex = getOptimalReplacement(currentStep);
                                break;
                            case 'lfu':
                                replaceIndex = getLFUReplacement();
                                break;
                            case 'mfu':
                                replaceIndex = getMFUReplacement();
                                break;
                            default:
                                replaceIndex = 0;
                        }
                    }
                    
                    // Record victim before replacement
                    victim = frames[replaceIndex];
                    
                    // Replace page
                    frames[replaceIndex] = page;
                    
                    // Update page load order for FIFO
                    if (victim !== null) {
                        // Remove victim from load order
                        const victimIndex = pageLoadOrder.indexOf(victim);
                        if (victimIndex !== -1) {
                            pageLoadOrder.splice(victimIndex, 1);
                        }
                    }
                    // Add new page to end of load order
                    pageLoadOrder.push(page);
                } else {
                    // Page hit
                    pageHits++;
                }
                
                // Increment counter for this page (for LFU/MFU)
                counters[page]++;
                
                // Save history
                history[currentStep + 1] = { 
                    frames: [...frames], 
                    counters: {...counters},
                    pageFault, 
                    victim, 
                    accessed: page,
                    pageLoadOrder: [...pageLoadOrder]
                };
                
                // Update UI
                renderFrames();
                if (['lfu', 'mfu'].includes(algorithmSelect.value)) {
                    renderCounters();
                }
                updateResults();
                
                // Update button states
                prevStepButton.disabled = currentStep <= 0;
                nextStepButton.disabled = currentStep >= referenceString.length - 1;
            }
            
            // Previous step logic
            function prevStep() {
                if (currentStep <= 0) return;
                
                // If this step was a page fault, decrement counter
                if (history[currentStep + 1].pageFault) {
                    pageFaults--;
                } else {
                    pageHits--;
                }
                
                // Restore previous state
                frames = [...history[currentStep].frames];
                counters = {...history[currentStep].counters};
                pageLoadOrder = [...history[currentStep].pageLoadOrder];
                currentStep--;
                
                // Update UI
                renderFrames();
                if (['lfu', 'mfu'].includes(algorithmSelect.value)) {
                    renderCounters();
                }
                updateResults();
                
                // Update button states
                prevStepButton.disabled = currentStep <= 0;
                nextStepButton.disabled = false;
            }
            
            // FIFO replacement policy
            function getFIFOReplacement() {
                // In FIFO, we replace the page that has been in memory the longest
                // This is the first page in our pageLoadOrder array
                if (pageLoadOrder.length > 0) {
                    const oldestPage = pageLoadOrder[0];
                    return frames.indexOf(oldestPage);
                }
                return 0; // Default to first frame if something went wrong
            }
            
            // LRU replacement policy
            function getLRUReplacement() {
                // For LRU, we need to track when each page was last used
                // For LRU, we need to track when each page was last used
                const pageLastUsed = {};
                    
                    // Initialize with very old timestamps for all pages in frames
                    frames.forEach(page => {
                        if (page !== null) {
                            pageLastUsed[page] = -1;
                        }
                    });
                    
                    // Go through history to find the last use of each page
                    for (let i = 0; i <= currentStep; i++) {
                        const page = referenceString[i];
                        if (frames.includes(page)) {
                            pageLastUsed[page] = i;
                        }
                    }
                    
                    // Find the page with the smallest timestamp (least recently used)
                    let lruPage = null;
                    let lruTimestamp = Infinity;
                    
                    for (const page in pageLastUsed) {
                        if (pageLastUsed[page] < lruTimestamp && frames.includes(parseInt(page))) {
                            lruTimestamp = pageLastUsed[page];
                            lruPage = parseInt(page);
                        }
                    }
                    
                    return frames.indexOf(lruPage);
                }
                
                // Optimal replacement policy
                function getOptimalReplacement(currentStep) {
                    // For Optimal, we need to look ahead to find which page won't be used for the longest time
                    const pageNextUse = {};
                    
                    // Initialize with infinity (meaning never used again) for all pages in frames
                    frames.forEach(page => {
                        if (page !== null) {
                            pageNextUse[page] = Infinity;
                        }
                    });
                    
                    // Look ahead to find next use of each page
                    for (let i = currentStep + 1; i < referenceString.length; i++) {
                        const page = referenceString[i];
                        if (frames.includes(page) && pageNextUse[page] === Infinity) {
                            pageNextUse[page] = i;
                        }
                    }
                    
                    // Find the page that won't be used for the longest time
                    let optimalPage = null;
                    let maxDistance = -1;
                    
                    for (const page in pageNextUse) {
                        if (pageNextUse[page] > maxDistance && frames.includes(parseInt(page))) {
                            maxDistance = pageNextUse[page];
                            optimalPage = parseInt(page);
                        }
                    }
                    
                    return frames.indexOf(optimalPage);
                }
                
                // LFU replacement policy
                function getLFUReplacement() {
                    // For LFU, we replace the page with the lowest access count
                    let minCount = Infinity;
                    let lfuPage = null;
                    
                    // Find page with minimum access count
                    frames.forEach(page => {
                        if (page !== null && counters[page] < minCount) {
                            minCount = counters[page];
                            lfuPage = page;
                        }
                    });
                    
                    return frames.indexOf(lfuPage);
                }
                
                // MFU replacement policy
                function getMFUReplacement() {
                    // For MFU, we replace the page with the highest access count
                    let maxCount = -1;
                    let mfuPage = null;
                    
                    // Find page with maximum access count
                    frames.forEach(page => {
                        if (page !== null && counters[page] > maxCount) {
                            maxCount = counters[page];
                            mfuPage = page;
                        }
                    });
                    
                    return frames.indexOf(mfuPage);
                }
                
                // Initialize the visualization
                init();
            });
    </script>
</body>
</html>