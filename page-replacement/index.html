<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page Replacement Algorithm Visualization</title>
    <style>
       /* Reset and Base Styles */
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    padding: 0;
    margin: 0;
    background-color: #0a0d1a;
    color: #e6edf3;
}

/* Header Section */
.header {
    background-color: #131b36;
    padding: 2rem 1rem;
    text-align: center;
}

.header h1 {
    color: #ffffff;
    margin: 0;
    font-size: 2.2rem;
    font-weight: 600;
}

.header p {
    color: rgba(255, 255, 255, 0.85);
    margin-top: 0.5rem;
    font-size: 1rem;
    max-width: 700px;
    margin-left: auto;
    margin-right: auto;
}

/* Controls Panel */
.controls-panel {
    background-color: #131b30;
    border-radius: 8px;
    padding: 1.5rem;
    margin: 1.5rem auto;
    max-width: 900px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

.controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
}

.control-group {
    margin-bottom: 1rem;
}

.control-group label {
    display: block;
    margin-bottom: 0.5rem;
    color: #a8b1cf;
    font-size: 0.95rem;
}

.control-group select,
.control-group input {
    width: 100%;
    padding: 0.7rem;
    border-radius: 4px;
    border: 1px solid #253051;
    background-color: #0c1224;
    color: white;
    font-size: 0.95rem;
}

.control-group select:focus,
.control-group input:focus {
    outline: none;
    border-color: #2a3f8d;
    box-shadow: 0 0 0 2px rgba(42, 63, 141, 0.25);
}

/* Buttons */
.button-group {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-top: 1.5rem;
}

.btn {
    padding: 0.7rem 1.5rem;
    border-radius: 4px;
    border: none;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.btn-primary {
    background-color: #2a3f8d;
    color: white;
}

.btn-primary:hover {
    background-color: #3a51a8;
    transform: translateY(-2px);
}

.btn-secondary {
    background-color: #1e2640;
    color: #bcc3e4;
}

.btn-secondary:hover {
    background-color: #2a3454;
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
}

/* Legend */
.legend {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 1.5rem;
    margin: 1.5rem auto;
    max-width: 900px;
    background-color: #131b30;
    border-radius: 8px;
    padding: 1rem;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.legend-color {
    width: 12px;
    height: 12px;
    border-radius: 3px;
}

.legend-label {
    font-size: 0.9rem;
    color: #a8b1cf;
}

/* Navigation Buttons */
.nav-buttons {
    display: flex;
    justify-content: center;
    gap: 0.75rem;
    margin: 1.5rem auto;
    max-width: 900px;
}

.btn-nav {
    padding: 0.6rem 1.25rem;
    border-radius: 4px;
    border: none;
    background-color: #1e2640;
    color: #bcc3e4;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.btn-nav:hover {
    background-color: #2a3454;
}

.btn-play {
    background-color: #1a5d3a;
    color: white;
}

.btn-play:hover {
    background-color: #207245;
}

.btn-nav:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background-color: #16192a;
}

/* Icons */
.icon {
    font-size: 1rem;
}

/* Tab System */
.tabs {
    display: flex;
    gap: 5px;
    margin: 0 auto;
    max-width: 900px;
    margin-bottom: 0;
}

.tab {
    padding: 0.7rem 1.5rem;
    background-color: #131b30;
    cursor: pointer;
    border-radius: 5px 5px 0 0;
    border: 1px solid #253051;
    border-bottom: none;
    color: #a8b1cf;
    transition: background-color 0.3s;
}

.tab:hover {
    background-color: #1e2640;
}

.tab.active {
    background-color: #2a3f8d;
    font-weight: bold;
    color: #ffffff;
}

.tab-content {
    border: 1px solid #253051;
    padding: 1.5rem;
    background-color: #131b30;
    border-radius: 0 5px 5px 5px;
    margin: 0 auto;
    max-width: 900px;
    margin-bottom: 2rem;
}

.visualization {
    padding: 0;
}
        
h2, h3 {
    color: #58a6ff;
    text-align: center;
    margin-top: 0;
}

/* Visualization Elements */
.reference-display {
    display: flex;
    overflow-x: auto;
    padding-bottom: 10px;
    margin-bottom: 20px;
    scrollbar-width: thin;
    scrollbar-color: #2a3f8d #0a0d1a;
}

.reference-display::-webkit-scrollbar {
    height: 8px;
}

.reference-display::-webkit-scrollbar-track {
    background: #0c1224;
    border-radius: 4px;
}

.reference-display::-webkit-scrollbar-thumb {
    background-color: #2a3f8d;
    border-radius: 4px;
}

.reference-cell {
    flex: 0 0 40px;
    height: 40px;
    border: 1px solid #253051;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #0c1224;
    font-weight: bold;
    color: #e6edf3;
}

.reference-cell.current {
    background-color: #2a3f8d;
    color: white;
    border-color: #1e2640;
    box-shadow: 0 0 10px rgba(42, 63, 141, 0.7);
}

.frame-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.frames {
    display: flex;
    overflow-x: auto;
    scrollbar-width: thin;
    scrollbar-color: #2a3f8d #0a0d1a;
}

.frames::-webkit-scrollbar {
    height: 8px;
}

.frames::-webkit-scrollbar-track {
    background: #0c1224;
    border-radius: 4px;
}

.frames::-webkit-scrollbar-thumb {
    background-color: #2a3f8d;
    border-radius: 4px;
}

.frame-column {
    display: flex;
    flex-direction: column;
    min-width: 40px;
    border-right: 1px solid #253051;
}

.frame-cell {
    height: 40px;
    width: 40px;
    border: 1px solid #253051;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #0c1224;
    color: #e6edf3;
    position: relative;
    transition: all 0.3s ease;
}

.frame-cell.page-fault {
    background-color: #c0392b;
    color: white;
    border-color: #a93226;
    animation: pulse 1s;
}

.frame-cell.page-hit {
    background-color: #1a5d3a;
    color: white;
    border-color: #145a32;
    animation: scale 0.5s;
}

.frame-cell.victim {
    background-color: #7d3c98;
    color: white;
    border-color: #6c3483;
    animation: fadeOut 1s;
}

.status-indicator {
    position: absolute;
    top: -22px;
    left: 0;
    width: 100%;
    text-align: center;
    font-size: 10px;
    padding: 2px 0;
    border-radius: 4px 4px 0 0;
    font-weight: bold;
    opacity: 0.9;
}

.status-indicator.fault {
    background-color: #c0392b;
    color: white;
}

.status-indicator.hit {
    background-color: #1a5d3a;
    color: white;
}

.results {
    margin-top: 20px;
    padding: 15px;
    background-color: #131b36;
    border-radius: 8px;
    border: 1px solid #2a3f8d;
    color: #e6edf3;
}

.step-message {
    margin-top: 20px;
    padding: 10px;
    background-color: #131b30;
    border-radius: 8px;
    border: 1px solid #253051;
    font-weight: bold;
    text-align: center;
}

.algorithm-info {
    margin-top: 20px;
    padding: 15px;
}

/* Badges */
.badge {
    position: absolute;
    padding: 2px 4px;
    font-size: 9px;
    font-weight: bold;
    border-radius: 3px;
    text-transform: uppercase;
}

.badge.fault {
    background-color: #c0392b;
    color: white;
    bottom: 2px;
    right: 2px;
}

.badge.hit {
    background-color: #1a5d3a;
    color: white;
    bottom: 2px;
    right: 2px;
}

.badge.victim {
    background-color: #7d3c98;
    color: white;
    top: 2px;
    left: 2px;
}

/* Reference Bit Indicator */
.ref-bit {
    position: absolute;
    top: 2px;
    right: 2px;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: #58a6ff;
}

.ref-bit.off {
    background-color: #636e7b;
}

/* Enhanced Second Chance Info */
.e2c-info {
    position: absolute;
    top: 2px;
    right: 2px;
    font-size: 8px;
    background-color: #2a3f8d;
    color: white;
    border-radius: 4px;
    padding: 1px 3px;
}

/* Animations */
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

@keyframes scale {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

@keyframes fadeOut {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}
    </style>
</head>
<body>
    <!-- Header Section -->
    <div class="header">
        <h1>Page Replacement Algorithm Visualization</h1>
        <p>Interactive tool to visualize and understand how different page replacement algorithms work in operating systems</p>
    </div>

    <!-- Controls Panel -->
    <div class="controls-panel">
        <div class="controls-grid">
            <div class="control-group">
                <label for="algorithm">Algorithm</label>
                <select id="algorithm">
                    <option value="fifo">FIFO (First-In-First-Out)</option>
                    <option value="lru">LRU (Least Recently Used)</option>
                    <option value="optimal">Optimal</option>
                    <option value="lfu">LFU (Least Frequently Used)</option>
                    <option value="mfu">MFU (Most Frequently Used)</option>
                    <option value="additional-reference-bit">Additional Reference Bit</option>
                    <option value="second-chance">Second Chance</option>
                    <option value="enhanced-second-chance">Enhanced Second Chance</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="frames">Number of Frames</label>
                <input type="number" id="frames" min="1" max="10" value="3">
            </div>
            
            <div class="control-group">
                <label for="reference-string">Reference String</label>
                <input type="text" id="reference-string" value="7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1">
            </div>
        </div>
        
        <div class="button-group">
            <button id="start" class="btn btn-primary">
                <span class="icon">▶</span> Start Visualization
            </button>
            <button id="reset" class="btn btn-secondary" disabled>
                <span class="icon">⟲</span> Reset
            </button>
        </div>
    </div>

    <!-- Navigation Buttons -->
    <div class="nav-buttons">
        <button id="prev-step" class="btn-nav" disabled>
            <span class="icon">◀</span> Previous
        </button>
        <button id="next-step" class="btn-nav" disabled>
            Next <span class="icon">▶</span>
        </button>
        <button id="auto-play" class="btn-nav btn-play" disabled>
            <span class="icon">⏵</span> Auto Play
        </button>
    </div>
    
    <!-- Legend -->
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background-color: #4c5fec;"></div>
            <span class="legend-label">Current Reference</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #2ecc71;"></div>
            <span class="legend-label">Page Hit</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #e74c3c;"></div>
            <span class="legend-label">Page Fault</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #58a6ff;"></div>
            <span class="legend-label">Reference Bit Set</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #636e7b;"></div>
            <span class="legend-label">Reference Bit Cleared</span>
        </div>
    </div>
    
    <!-- Tabs -->
    <div class="tabs">
        <div class="tab active" data-tab="visualization">Visualization</div>
        <div class="tab" data-tab="algorithm-info">Algorithm Info</div>
    </div>
    
    <!-- Visualization Tab Content -->
    <div class="tab-content" id="visualization-tab">
        <div class="visualization">
            <h2>Page Reference Sequence</h2>
            <div class="reference-display" id="reference-display"></div>
            
            <div id="step-message" class="step-message">
                Press "Start Visualization" to begin...
            </div>
            
            <h2>Memory Frames</h2>
            <div class="frame-container">
                <div class="frames" id="frames-display"></div>
            </div>
            
            <div class="results" id="results">
                <p>Press "Start Visualization" to begin...</p>
            </div>
        </div>
    </div>
    
    <!-- Algorithm Info Tab Content -->
    <div class="tab-content" id="algorithm-info-tab" style="display:none;">
        <div class="algorithm-info">
            <h2>Page Replacement Algorithms</h2>
            
            <h3>FIFO (First-In-First-Out)</h3>
            <p>The simplest page replacement algorithm that replaces the oldest page in memory. It maintains a queue of pages, where the oldest page is at the front of the queue.</p>
            <p><strong>Advantage:</strong> Simple to implement and understand.</p>
            <p><strong>Disadvantage:</strong> Does not consider page usage frequency, leading to potential replacement of frequently used pages.</p>
            
            <h3>LRU (Least Recently Used)</h3>
            <p>Replaces the page that has not been used for the longest period of time. It keeps track of when each page was last accessed.</p>
            <p><strong>Advantage:</strong> Better performance than FIFO as it considers temporal locality.</p>
            <p><strong>Disadvantage:</strong> Requires additional overhead to track page usage history.</p>
            
            <h3>Optimal</h3>
            <p>Replaces the page that will not be used for the longest period of time in the future. This is a theoretical algorithm that requires future knowledge of page references.</p>
            <p><strong>Advantage:</strong> Provides the lowest possible page fault rate, serves as a benchmark.</p>
            <p><strong>Disadvantage:</strong> Not practically implementable in real systems as it requires knowledge of future references.</p>
            
            <h3>LFU (Least Frequently Used)</h3>
            <p>Replaces the page that has been used least frequently. It keeps a counter for each page and increments it on each access.</p>
            <p><strong>Advantage:</strong> Can perform better than LRU when access patterns have cyclical behavior.</p>
            <p><strong>Disadvantage:</strong> May keep pages with high historical frequency but no recent usage, leading to potential thrashing.</p>
            
            <h3>MFU (Most Frequently Used)</h3>
            <p>Replaces the page that has been used most frequently. Based on the logic that pages with high frequency counter values have completed their use and won't be used again soon.</p>
            <p><strong>Advantage:</strong> Can work well in certain specialized workloads.</p>
            <p><strong>Disadvantage:</strong> Generally performs worse than LFU and LRU in most common scenarios.</p>
            
            <h3>Additional Reference Bit Algorithm</h3>
            <p>An approximation of LRU that uses a reference bit and periodically shifts it into an 8-bit register to keep track of page usage history.</p>
            <p><strong>Advantage:</strong> More efficient than pure LRU while still capturing temporal locality patterns.</p>
            <p><strong>Disadvantage:</strong> Less accurate than true LRU but requires significantly less overhead.</p>
            
            <h3>Second Chance (Clock) Algorithm</h3>
            <p>A modification of FIFO that gives pages a "second chance" if they have been referenced since they were loaded. It uses a circular queue with a reference bit for each page.</p>
            <p><strong>Advantage:</strong> Simple to implement and better than FIFO by considering page usage.</p>
            <p><strong>Disadvantage:</strong> May require multiple passes through the queue to find a page for replacement.</p>
            
            <h3>Enhanced Second Chance Algorithm</h3>
            <p>An enhancement to the Second Chance algorithm that considers both the reference bit and the modify bit (dirty bit) to make better replacement decisions.</p>
            <p><strong>Advantage:</strong> Better performance by considering both usage and modification status.</p>
            <p><strong>Disadvantage:</strong> More complex implementation than Second Chance.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM Elements
            const algorithmSelect = document.getElementById('algorithm');
            const framesInput = document.getElementById('frames');
            const referenceStringInput = document.getElementById('reference-string');
            const startButton = document.getElementById('start');
            const resetButton = document.getElementById('reset');
            const prevStepButton = document.getElementById('prev-step');
            const nextStepButton = document.getElementById('next-step');
            const autoPlayButton = document.getElementById('auto-play');
            const referenceDisplay = document.getElementById('reference-display');
            const framesDisplay = document.getElementById('frames-display');
            const resultsDiv = document.getElementById('results');
            const stepMessageDiv = document.getElementById('step-message');
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            
            // Variables
            let referenceString = [];
            let frames = [];
            let counters = {}; // For LFU and MFU
            let referenceBits = {}; // For additional reference bit, second chance and enhanced second chance
            let modifyBits = {}; // For enhanced second chance
            let historyBits = {}; // For additional reference bit
            let clockPointer = 0; // For second chance and enhanced second chance
            let currentStep = -1;
            let pageFaults = 0;
            let pageHits = 0;
            let history = [];
            let autoPlayInterval;
            let isAutoPlaying = false;
            
            // Track page load order for FIFO algorithm
            let pageLoadOrder = [];
            
            // Initialize
            function init() {
                algorithmSelect.disabled = false;
                framesInput.disabled = false;
                referenceStringInput.disabled = false;
                startButton.disabled = false;
                resetButton.disabled = true;
                prevStepButton.disabled = true;
                nextStepButton.disabled = true;
                autoPlayButton.disabled = true;
                
                referenceDisplay.innerHTML = '';
                framesDisplay.innerHTML = '';
                resultsDiv.innerHTML = '<p>Press "Start Visualization" to begin...</p>';
                stepMessageDiv.innerHTML = 'Press "Start Visualization" to begin...';
                
                referenceString = [];
                frames = [];
                counters = {};
                referenceBits = {};
                modifyBits = {};
                historyBits = {};
                clockPointer = 0;
                pageLoadOrder = [];
                currentStep = -1;
                pageFaults = 0;
                pageHits = 0;
                history = [];
                
                clearInterval(autoPlayInterval);
                isAutoPlaying = false;
                autoPlayButton.textContent = '⏵ Auto Play';
            }
            
            // Start visualization
            startButton.addEventListener('click', function() {
                // Parse reference string
                referenceString = referenceStringInput.value
                    .trim()
                    .split(/\s+/)
                    .map(n => parseInt(n));
                
                // Validate reference string
                if (referenceString.some(isNaN)) {
                    alert('Invalid reference string. Please enter space-separated numbers.');
                    return;
                }
                
                // Get number of frames
                const numFrames = parseInt(framesInput.value);
                if (isNaN(numFrames) || numFrames < 1 || numFrames > 10) {
                    alert('Number of frames must be between 1 and 10.');
                    return;
                }
                
                // Initialize frames
                frames = Array(numFrames).fill(null);
                
                // Initialize counters, reference bits, and modify bits for each possible page in reference string
                const uniquePages = new Set(referenceString);
                uniquePages.forEach(page => {
                    counters[page] = 0;
                    referenceBits[page] = 0;
                    modifyBits[page] = 0;
                    // Initialize history bits for additional reference bit algorithm
                    historyBits[page] = 0; // 8-bit history (0-255)
                });
                
                // Reset page load order and clock pointer
                pageLoadOrder = [];
                clockPointer = 0;
                
                // Update UI
                algorithmSelect.disabled = true;
                framesInput.disabled = true;
                referenceStringInput.disabled = true;
                startButton.disabled = true;
                resetButton.disabled = false;
                nextStepButton.disabled = false;
                autoPlayButton.disabled = false;
                
                // Initialize visualization
                renderReferenceString();
                renderFrames();
                currentStep = -1;
                pageFaults = 0;
                pageHits = 0;
                history = [{ 
                    frames: [...frames], 
                    counters: {...counters},
                    referenceBits: {...referenceBits},
                    modifyBits: {...modifyBits},
                    historyBits: {...historyBits},
                    clockPointer: clockPointer,
                    pageFault: false, 
                    victim: null, 
                    accessed: null,
                    pageLoadOrder: [...pageLoadOrder],
                    stepDescription: "Initial state: All frames are empty."
                }];
                
                stepMessageDiv.innerHTML = "Initial state: All frames are empty. Press 'Next Step' to begin.";
                updateResults();
            });
            
            // Reset visualization
            resetButton.addEventListener('click', init);
            
            // Next step
            nextStepButton.addEventListener('click', nextStep);
            
            // Previous step
            prevStepButton.addEventListener('click', prevStep);
            
            // Auto play
            autoPlayButton.addEventListener('click', function() {
                if (isAutoPlaying) {
                    clearInterval(autoPlayInterval);
                    isAutoPlaying = false;
                    autoPlayButton.innerHTML = '<span class="icon">⏵</span> Auto Play';
                } else {
                    isAutoPlaying = true;
                    autoPlayButton.innerHTML = '<span class="icon">⏸</span> Stop';
                    autoPlayInterval = setInterval(() => {
                        if (currentStep >= referenceString.length - 1) {
                            clearInterval(autoPlayInterval);
                            isAutoPlaying = false;
                            autoPlayButton.innerHTML = '<span class="icon">⏵</span> Auto Play';
                            return;
                        }
                        nextStep();
                    }, 800);
                }
            });
            
            // Tab switching
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    // Remove active class from all tabs
                    tabs.forEach(t => t.classList.remove('active'));
                    // Add active class to clicked tab
                    this.classList.add('active');
                    
                    // Hide all tab contents
                    tabContents.forEach(content => content.style.display = 'none');
                    // Show selected tab content
                    document.getElementById(`${this.dataset.tab}-tab`).style.display = 'block';
                });
            });
            
            // Render reference string
            function renderReferenceString() {
                referenceDisplay.innerHTML = '';
                
                referenceString.forEach((page, index) => {
                    const cell = document.createElement('div');
                    cell.className = 'reference-cell';
                    cell.id = `ref-${index}`;
                    cell.textContent = page;
                    referenceDisplay.appendChild(cell);
                });
            }

            // Render memory frames with status indicators
            function renderFrames() {
                framesDisplay.innerHTML = '';
                
                // Create initial column for frame numbers
                const frameNumberColumn = document.createElement('div');
                frameNumberColumn.className = 'frame-column';
                
                for (let i = 0; i < frames.length; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'frame-cell';
                    cell.textContent = `F${i}`;
                    cell.style.fontWeight = 'bold';
                    cell.style.backgroundColor = '#2d333b';
                    frameNumberColumn.appendChild(cell);
                }
                
                framesDisplay.appendChild(frameNumberColumn);
                
                // Create a column for each step in history
                for (let i = 0; i <= currentStep + 1; i++) {
                    if (i >= history.length) continue;
                    
                    const state = history[i];
                    const column = document.createElement('div');
                    column.className = 'frame-column';
                    column.id = `step-${i}`;
                    
                    // For the current step, add a header indicator
                    if (i === currentStep + 1 && i > 0) {
                        const stepHeader = document.createElement('div');
                        if (state.pageFault) {
                            stepHeader.className = 'status-indicator fault';
                            stepHeader.textContent = 'PAGE FAULT';
                        } else if (state.accessed !== null) {
                            stepHeader.className = 'status-indicator hit';
                            stepHeader.textContent = 'PAGE HIT';
                        }
                        column.appendChild(stepHeader);
                    }
                    
                    for (let j = 0; j < frames.length; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'frame-cell';
                        
                        // Set content
                        if (state.frames[j] !== null) {
                            cell.textContent = state.frames[j];
                            
                           // Add reference bit indicator for relevant algorithms
                           if (['additional-reference-bit', 'second-chance', 'enhanced-second-chance'].includes(algorithmSelect.value)) {
                                const page = state.frames[j];
                                if (page !== null) {
                                    // Add reference bit indicator
                                    const refBit = document.createElement('div');
                                    refBit.className = `ref-bit ${state.referenceBits[page] ? '' : 'off'}`;
                                    cell.appendChild(refBit);
                                    
                                    // For enhanced second chance, show class (R,M)
                                    if (algorithmSelect.value === 'enhanced-second-chance') {
                                        const e2cInfo = document.createElement('div');
                                        e2cInfo.className = 'e2c-info';
                                        e2cInfo.textContent = `${state.referenceBits[page]},${state.modifyBits[page]}`;
                                        cell.appendChild(e2cInfo);
                                    }
                                }
                            }
                            
                            // Add badges for fault, hit, and victim
                            if (i === currentStep + 1 && i > 0) {
                                // Page fault badge
                                if (state.pageFault && state.frames[j] === state.accessed) {
                                    const faultBadge = document.createElement('div');
                                    faultBadge.className = 'badge fault';
                                    faultBadge.textContent = 'F';
                                    cell.appendChild(faultBadge);
                                    cell.classList.add('page-fault');
                                }
                                
                                // Page hit badge
                                if (!state.pageFault && state.frames[j] === state.accessed) {
                                    const hitBadge = document.createElement('div');
                                    hitBadge.className = 'badge hit';
                                    hitBadge.textContent = 'H';
                                    cell.appendChild(hitBadge);
                                    cell.classList.add('page-hit');
                                }
                                
                                // Victim badge
                                if (state.victim !== null && state.frames[j] === state.victim) {
                                    const victimBadge = document.createElement('div');
                                    victimBadge.className = 'badge victim';
                                    victimBadge.textContent = 'V';
                                    cell.appendChild(victimBadge);
                                    cell.classList.add('victim');
                                }
                            }
                        }
                        
                        column.appendChild(cell);
                    }
                    
                    framesDisplay.appendChild(column);
                }
            }
            
            // Update results display
            function updateResults() {
                resultsDiv.innerHTML = `
                    <p><strong>Page Faults:</strong> ${pageFaults}</p>
                    <p><strong>Page Hits:</strong> ${pageHits}</p>
                    <p><strong>Total References:</strong> ${currentStep + 1}</p>
                    <p><strong>Page Fault Rate:</strong> ${currentStep >= 0 ? ((pageFaults / (currentStep + 1)) * 100).toFixed(2) : 0}%</p>
                `;
            }
            
            // Function to process next step
            function nextStep() {
                if (currentStep >= referenceString.length - 1) return;
                
                currentStep++;
                const page = referenceString[currentStep];
                
                // Update reference string display
                document.querySelectorAll('.reference-cell').forEach(cell => cell.classList.remove('current'));
                document.getElementById(`ref-${currentStep}`).classList.add('current');
                
                // Check if page is already in frames (page hit)
                const frameIndex = frames.indexOf(page);
                let pageFault = frameIndex === -1;
                let victim = null;
                
                // Update counters for LFU/MFU
                counters[page] = (counters[page] || 0) + 1;
                
                // Set reference bit for relevant algorithms
                referenceBits[page] = 1;
                
                // For the sake of visualization, randomly set modify bit in enhanced second chance
                if (algorithmSelect.value === 'enhanced-second-chance') {
                    // 30% chance of modifying the page
                    modifyBits[page] = Math.random() < 0.3 ? 1 : 0;
                }
                
                // Update history bits for additional reference bit algorithm
                if (algorithmSelect.value === 'additional-reference-bit') {
                    // Shift existing history one bit to the right and add reference bit to MSB
                    historyBits[page] = ((historyBits[page] >> 1) | (referenceBits[page] << 7)) & 0xFF;
                }
                
                // Handle page replacement based on selected algorithm
                if (pageFault) {
                    pageFaults++;
                    
                    // Find empty frame if available
                    const emptyFrameIndex = frames.indexOf(null);
                    
                    if (emptyFrameIndex !== -1) {
                        // Place page in empty frame
                        frames[emptyFrameIndex] = page;
                        pageLoadOrder.push(page);
                    } else {
                        // Need to replace a page
                        let victimIndex = -1;
                        
                        switch (algorithmSelect.value) {
                            case 'fifo':
                                // First-In-First-Out: replace the oldest page
                                const oldestPage = pageLoadOrder[0];
                                victimIndex = frames.indexOf(oldestPage);
                                pageLoadOrder.shift();
                                pageLoadOrder.push(page);
                                break;
                                
                            case 'lru':
                                // Least Recently Used: find the page used least recently
                                // For simplicity, we'll use the position in history
                                let leastRecentIndex = 0;
                                let leastRecentStep = currentStep;
                                
                                for (let i = 0; i < frames.length; i++) {
                                    const framePage = frames[i];
                                    // Find the most recent access to this page before current step
                                    let lastAccess = -1;
                                    for (let j = currentStep - 1; j >= 0; j--) {
                                        if (referenceString[j] === framePage) {
                                            lastAccess = j;
                                            break;
                                        }
                                    }
                                    
                                    if (lastAccess < leastRecentStep) {
                                        leastRecentStep = lastAccess;
                                        leastRecentIndex = i;
                                    }
                                }
                                
                                victimIndex = leastRecentIndex;
                                break;
                                
                            case 'optimal':
                                // Optimal: replace page that won't be used for longest time
                                let farthestUseIndex = 0;
                                let farthestUseStep = -1;
                                
                                for (let i = 0; i < frames.length; i++) {
                                    const framePage = frames[i];
                                    // Find next use of this page after current step
                                    let nextUse = Infinity;
                                    for (let j = currentStep + 1; j < referenceString.length; j++) {
                                        if (referenceString[j] === framePage) {
                                            nextUse = j;
                                            break;
                                        }
                                    }
                                    
                                    if (nextUse > farthestUseStep) {
                                        farthestUseStep = nextUse;
                                        farthestUseIndex = i;
                                    }
                                }
                                
                                victimIndex = farthestUseIndex;
                                break;
                                
                            case 'lfu':
                                // Least Frequently Used: replace page with lowest counter
                                let minCount = Infinity;
                                let minCountIndex = 0;
                                
                                for (let i = 0; i < frames.length; i++) {
                                    const framePage = frames[i];
                                    if (counters[framePage] < minCount) {
                                        minCount = counters[framePage];
                                        minCountIndex = i;
                                    }
                                }
                                
                                victimIndex = minCountIndex;
                                break;
                                
                            case 'mfu':
                                // Most Frequently Used: replace page with highest counter
                                let maxCount = -1;
                                let maxCountIndex = 0;
                                
                                for (let i = 0; i < frames.length; i++) {
                                    const framePage = frames[i];
                                    if (counters[framePage] > maxCount) {
                                        maxCount = counters[framePage];
                                        maxCountIndex = i;
                                    }
                                }
                                
                                victimIndex = maxCountIndex;
                                break;
                                
                            case 'additional-reference-bit':
                                // Additional Reference Bit: replace page with lowest history value
                                let minHistory = Infinity;
                                let minHistoryIndex = 0;
                                
                                for (let i = 0; i < frames.length; i++) {
                                    const framePage = frames[i];
                                    if (historyBits[framePage] < minHistory) {
                                        minHistory = historyBits[framePage];
                                        minHistoryIndex = i;
                                    }
                                }
                                
                                victimIndex = minHistoryIndex;
                                break;
                                
                            case 'second-chance':
                                // Second Chance: FIFO with reference bit check
                                let currentPointer = clockPointer;
                                let found = false;
                                
                                // First pass: look for pages with reference bit = 0
                                for (let i = 0; i < frames.length; i++) {
                                    const frameIndex = (currentPointer + i) % frames.length;
                                    const framePage = frames[frameIndex];
                                    
                                    if (referenceBits[framePage] === 0) {
                                        victimIndex = frameIndex;
                                        found = true;
                                        clockPointer = (frameIndex + 1) % frames.length;
                                        break;
                                    } else {
                                        // Give second chance: clear reference bit
                                        referenceBits[framePage] = 0;
                                    }
                                }
                                
                                // If no page with reference bit = 0 is found, select the current pointer position
                                if (!found) {
                                    victimIndex = currentPointer;
                                    clockPointer = (currentPointer + 1) % frames.length;
                                }
                                break;
                                
                            case 'enhanced-second-chance':
                                // Enhanced Second Chance: Consider both reference and modify bits
                                // Priority: (0,0) > (0,1) > (1,0) > (1,1)
                                let classes = [[], [], [], []];
                                
                                // Classify pages into classes (R,M)
                                for (let i = 0; i < frames.length; i++) {
                                    const framePage = frames[i];
                                    const classIndex = (referenceBits[framePage] << 1) | modifyBits[framePage];
                                    classes[classIndex].push(i);
                                }
                                
                                // Find the first non-empty class
                                for (let i = 0; i < classes.length; i++) {
                                    if (classes[i].length > 0) {
                                        // Use FIFO within the class
                                        victimIndex = classes[i][0];
                                        break;
                                    }
                                }
                                
                                // Update clock pointer for visualization
                                clockPointer = (victimIndex + 1) % frames.length;
                                break;
                                
                            default:
                                // Default to FIFO
                                const oldestPageDefault = pageLoadOrder[0];
                                victimIndex = frames.indexOf(oldestPageDefault);
                                pageLoadOrder.shift();
                                pageLoadOrder.push(page);
                        }
                        
                        victim = frames[victimIndex];
                        frames[victimIndex] = page;
                    }
                } else {
                    // Page hit: update usage information
                    pageHits++;
                    
                    // For LRU, update order (move to end)
                    if (algorithmSelect.value === 'lru') {
                        const index = pageLoadOrder.indexOf(page);
                        if (index !== -1) {
                            pageLoadOrder.splice(index, 1);
                            pageLoadOrder.push(page);
                        }
                    }
                }
                
                // Create a description for the current step
                let stepDescription = "";
                
                if (pageFault) {
                    if (victim === null) {
                        stepDescription = `Page ${page} not in memory. Page fault occurred. Page ${page} loaded into empty frame.`;
                    } else {
                        stepDescription = `Page ${page} not in memory. Page fault occurred. Page ${victim} was selected for replacement by ${algorithmSelect.options[algorithmSelect.selectedIndex].text}.`;
                    }
                } else {
                    stepDescription = `Page ${page} already in memory. Page hit occurred. No replacement needed.`;
                }
                
                // Add step to history
                history.push({
                    frames: [...frames],
                    counters: {...counters},
                    referenceBits: {...referenceBits},
                    modifyBits: {...modifyBits},
                    historyBits: {...historyBits},
                    clockPointer: clockPointer,
                    pageFault: pageFault,
                    victim: victim,
                    accessed: page,
                    pageLoadOrder: [...pageLoadOrder],
                    stepDescription: stepDescription
                });
                
                // Update UI
                renderFrames();
                updateResults();
                stepMessageDiv.innerHTML = stepDescription;
                
                // Update navigation buttons
                prevStepButton.disabled = false;
                nextStepButton.disabled = currentStep >= referenceString.length - 1;
                
                // Scroll reference string to keep current page in view
                if (currentStep > 5) {
                    const cellWidth = 42; // Width of reference cell + margins
                    referenceDisplay.scrollLeft = (currentStep - 5) * cellWidth;
                }
                
                // Scroll frames to keep current step in view
                const frameColumnWidth = 42; // Width of frame column
                framesDisplay.scrollLeft = framesDisplay.scrollWidth;
            }
            
            // Function to go back to previous step
            function prevStep() {
                if (currentStep < 0) return;
                
                // Remove the last state from history
                if (history.length > 1) {
                    history.pop();
                }
                
                // Restore previous state
                const prevState = history[history.length - 1];
                frames = [...prevState.frames];
                counters = {...prevState.counters};
                referenceBits = {...prevState.referenceBits};
                modifyBits = {...prevState.modifyBits};
                historyBits = {...prevState.historyBits};
                clockPointer = prevState.clockPointer;
                pageLoadOrder = [...prevState.pageLoadOrder];
                
                // Update counters
                if (currentStep >= 0) {
                    const page = referenceString[currentStep];
                    if (prevState.pageFault) {
                        pageFaults--;
                    } else {
                        pageHits--;
                    }
                }
                
                currentStep--;
                
                // Update UI
                renderFrames();
                updateResults();
                
                // Update reference string display
                document.querySelectorAll('.reference-cell').forEach(cell => cell.classList.remove('current'));
                if (currentStep >= 0) {
                    document.getElementById(`ref-${currentStep}`).classList.add('current');
                }
                
                // Update step message
                stepMessageDiv.innerHTML = prevState.stepDescription;
                
                // Update navigation buttons
                nextStepButton.disabled = false;
                prevStepButton.disabled = currentStep < 0;
            }
            
            // Initialize the visualization
            init();
        });
    </script>
</body>
</html>
