<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page Replacement Algorithm Visualization</title>
    <style>
       /* Reset and Base Styles */
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    padding: 0;
    margin: 0;
    background-color: #0a0d1a;
    color: #e6edf3;
}

/* Header Section */
.header {
    background-color: #131b36;
    padding: 2rem 1rem;
    text-align: center;
}

.header h1 {
    color: #ffffff;
    margin: 0;
    font-size: 2.2rem;
    font-weight: 600;
}

.header p {
    color: rgba(255, 255, 255, 0.85);
    margin-top: 0.5rem;
    font-size: 1rem;
    max-width: 700px;
    margin-left: auto;
    margin-right: auto;
}

/* Controls Panel */
.controls-panel {
    background-color: #131b30;
    border-radius: 8px;
    padding: 1.5rem;
    margin: 1.5rem auto;
    max-width: 900px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

.controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
}

.control-group {
    margin-bottom: 1rem;
}

.control-group label {
    display: block;
    margin-bottom: 0.5rem;
    color: #a8b1cf;
    font-size: 0.95rem;
}

.control-group select,
.control-group input {
    width: 100%;
    padding: 0.7rem;
    border-radius: 4px;
    border: 1px solid #253051;
    background-color: #0c1224;
    color: white;
    font-size: 0.95rem;
}

.control-group select:focus,
.control-group input:focus {
    outline: none;
    border-color: #2a3f8d;
    box-shadow: 0 0 0 2px rgba(42, 63, 141, 0.25);
}

/* Buttons */
.button-group {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-top: 1.5rem;
}

.btn {
    padding: 0.7rem 1.5rem;
    border-radius: 4px;
    border: none;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.btn-primary {
    background-color: #2a3f8d;
    color: white;
}

.btn-primary:hover {
    background-color: #3a51a8;
    transform: translateY(-2px);
}

.btn-secondary {
    background-color: #1e2640;
    color: #bcc3e4;
}

.btn-secondary:hover {
    background-color: #2a3454;
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
}

/* Legend */
.legend {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 1.5rem;
    margin: 1.5rem auto;
    max-width: 900px;
    background-color: #131b30;
    border-radius: 8px;
    padding: 1rem;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.legend-color {
    width: 12px;
    height: 12px;
    border-radius: 3px;
}

.legend-label {
    font-size: 0.9rem;
    color: #a8b1cf;
}

/* Navigation Buttons */
.nav-buttons {
    display: flex;
    justify-content: center;
    gap: 0.75rem;
    margin: 1.5rem auto;
    max-width: 900px;
}

.btn-nav {
    padding: 0.6rem 1.25rem;
    border-radius: 4px;
    border: none;
    background-color: #1e2640;
    color: #bcc3e4;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.btn-nav:hover {
    background-color: #2a3454;
}

.btn-play {
    background-color: #1a5d3a;
    color: white;
}

.btn-play:hover {
    background-color: #207245;
}

.btn-nav:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background-color: #16192a;
}

/* Icons */
.icon {
    font-size: 1rem;
}

/* Tab System */
.tabs {
    display: flex;
    gap: 5px;
    margin: 0 auto;
    max-width: 900px;
    margin-bottom: 0;
}

.tab {
    padding: 0.7rem 1.5rem;
    background-color: #131b30;
    cursor: pointer;
    border-radius: 5px 5px 0 0;
    border: 1px solid #253051;
    border-bottom: none;
    color: #a8b1cf;
    transition: background-color 0.3s;
}

.tab:hover {
    background-color: #1e2640;
}

.tab.active {
    background-color: #2a3f8d;
    font-weight: bold;
    color: #ffffff;
}

.tab-content {
    border: 1px solid #253051;
    padding: 1.5rem;
    background-color: #131b30;
    border-radius: 0 5px 5px 5px;
    margin: 0 auto;
    max-width: 900px;
    margin-bottom: 2rem;
}

.visualization {
    padding: 0;
}
        
h2, h3 {
    color: #58a6ff;
    text-align: center;
    margin-top: 0;
}

/* Visualization Elements */
.reference-display {
    display: flex;
    overflow-x: auto;
    padding-bottom: 10px;
    margin-bottom: 20px;
    scrollbar-width: thin;
    scrollbar-color: #2a3f8d #0a0d1a;
}

.reference-display::-webkit-scrollbar {
    height: 8px;
}

.reference-display::-webkit-scrollbar-track {
    background: #0c1224;
    border-radius: 4px;
}

.reference-display::-webkit-scrollbar-thumb {
    background-color: #2a3f8d;
    border-radius: 4px;
}

.reference-cell {
    flex: 0 0 40px;
    height: 40px;
    border: 1px solid #253051;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #0c1224;
    font-weight: bold;
    color: #e6edf3;
}

.reference-cell.current {
    background-color: #2a3f8d;
    color: white;
    border-color: #1e2640;
    box-shadow: 0 0 10px rgba(42, 63, 141, 0.7);
}

.frame-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.frames {
    display: flex;
    overflow-x: auto;
    scrollbar-width: thin;
    scrollbar-color: #2a3f8d #0a0d1a;
}

.frames::-webkit-scrollbar {
    height: 8px;
}

.frames::-webkit-scrollbar-track {
    background: #0c1224;
    border-radius: 4px;
}

.frames::-webkit-scrollbar-thumb {
    background-color: #2a3f8d;
    border-radius: 4px;
}

.frame-column {
    display: flex;
    flex-direction: column;
    min-width: 40px;
    border-right: 1px solid #253051;
}

.frame-cell {
    height: 40px;
    width: 40px;
    border: 1px solid #253051;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #0c1224;
    color: #e6edf3;
    position: relative;
    transition: all 0.3s ease;
}

.frame-cell.page-fault {
    background-color: #c0392b;
    color: white;
    border-color: #a93226;
    animation: pulse 1s;
}

.frame-cell.page-hit {
    background-color: #1a5d3a;
    color: white;
    border-color: #145a32;
    animation: scale 0.5s;
}

.frame-cell.victim {
    background-color: #7d3c98;
    color: white;
    border-color: #6c3483;
    animation: fadeOut 1s;
}

.status-indicator {
    position: absolute;
    top: -22px;
    left: 0;
    width: 100%;
    text-align: center;
    font-size: 10px;
    padding: 2px 0;
    border-radius: 4px 4px 0 0;
    font-weight: bold;
    opacity: 0.9;
}

.status-indicator.fault {
    background-color: #c0392b;
    color: white;
}

.status-indicator.hit {
    background-color: #1a5d3a;
    color: white;
}

.results {
    margin-top: 20px;
    padding: 15px;
    background-color: #131b36;
    border-radius: 8px;
    border: 1px solid #2a3f8d;
    color: #e6edf3;
}

.step-message {
    margin-top: 20px;
    padding: 10px;
    background-color: #131b30;
    border-radius: 8px;
    border: 1px solid #253051;
    font-weight: bold;
    text-align: center;
}

.algorithm-info {
    margin-top: 20px;
    padding: 15px;
}

/* Badges */
.badge {
    position: absolute;
    padding: 2px 4px;
    font-size: 9px;
    font-weight: bold;
    border-radius: 3px;
    text-transform: uppercase;
}

.badge.fault {
    background-color: #c0392b;
    color: white;
    bottom: 2px;
    right: 2px;
}

.badge.hit {
    background-color: #1a5d3a;
    color: white;
    bottom: 2px;
    right: 2px;
}

.badge.victim {
    background-color: #7d3c98;
    color: white;
    top: 2px;
    left: 2px;
}

/* Enhanced Second Chance Info */
.e2c-info {
    position: absolute;
    top: 2px;
    right: 2px;
    font-size: 8px;
    background-color: #2a3f8d;
    color: white;
    border-radius: 4px;
    padding: 1px 3px;
}

/* Animations */
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

@keyframes scale {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

@keyframes fadeOut {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}
    </style>
</head>
<body>
    <!-- Header Section -->
    <div class="header">
        <h1>Page Replacement Algorithm Visualization</h1>
        <p>Interactive tool to visualize and understand how different page replacement algorithms work in operating systems</p>
    </div>

    <!-- Controls Panel -->
    <div class="controls-panel">
        <div class="controls-grid">
            <div class="control-group">
                <label for="algorithm">Algorithm</label>
                <select id="algorithm">
                    <option value="fifo">FIFO (First-In-First-Out)</option>
                    <option value="lru">LRU (Least Recently Used)</option>
                    <option value="optimal">Optimal</option>
                    <option value="lfu">LFU (Least Frequently Used)</option>
                    <option value="mfu">MFU (Most Frequently Used)</option>
                    <option value="additional-reference-bit">Additional Reference Bit</option>
                    <option value="second-chance">Second Chance</option>
                    <option value="enhanced-second-chance">Enhanced Second Chance</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="frames">Number of Frames</label>
                <input type="number" id="frames" min="1" max="10" value="3">
            </div>
            
            <div class="control-group">
                <label for="reference-string">Reference String</label>
                <input type="text" id="reference-string" value="7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1">
            </div>
        </div>
        
        <div class="button-group">
            <button id="start" class="btn btn-primary">
                <span class="icon">▶</span> Start Visualization
            </button>
            <button id="reset" class="btn btn-secondary" disabled>
                <span class="icon">⟲</span> Reset
            </button>
        </div>
    </div>

    <!-- Navigation Buttons -->
    <div class="nav-buttons">
        <button id="prev-step" class="btn-nav" disabled>
            <span class="icon">◀</span> Previous
        </button>
        <button id="next-step" class="btn-nav" disabled>
            Next <span class="icon">▶</span>
        </button>
        <button id="auto-play" class="btn-nav btn-play" disabled>
            <span class="icon">⏵</span> Auto Play
        </button>
    </div>
    
    <!-- Legend -->
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background-color: #4c5fec;"></div>
            <span class="legend-label">Current Reference</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #2ecc71;"></div>
            <span class="legend-label">Page Hit</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #e74c3c;"></div>
            <span class="legend-label">Page Fault</span>
        </div>
    </div>
    
    <!-- Tabs -->
    <div class="tabs">
        <div class="tab active" data-tab="visualization">Visualization</div>
        <div class="tab" data-tab="algorithm-info">Algorithm Info</div>
    </div>
    
    <!-- Visualization Tab Content -->
    <div class="tab-content" id="visualization-tab">
        <div class="visualization">
            <h2>Page Reference Sequence</h2>
            <div class="reference-display" id="reference-display"></div>
            
            <div id="step-message" class="step-message">
                Press "Start Visualization" to begin...
            </div>
            
            <h2>Memory Frames</h2>
            <div class="frame-container">
                <div class="frames" id="frames-display"></div>
            </div>
            
            <div class="results" id="results">
                <p>Press "Start Visualization" to begin...</p>
            </div>
        </div>
    </div>
    
    <!-- Algorithm Info Tab Content -->
    <div class="tab-content" id="algorithm-info-tab" style="display:none;">
        <div class="algorithm-info">
            <h2>Page Replacement Algorithms</h2>
            
            <h3>FIFO (First-In-First-Out)</h3>
            <p>The simplest page replacement algorithm that replaces the oldest page in memory. It maintains a queue of pages, where the oldest page is at the front of the queue.</p>
            <p><strong>Advantage:</strong> Simple to implement and understand.</p>
            <p><strong>Disadvantage:</strong> Does not consider page usage frequency, leading to potential replacement of frequently used pages.</p>
            
            <h3>LRU (Least Recently Used)</h3>
            <p>Replaces the page that has not been used for the longest period of time. It keeps track of when each page was last accessed.</p>
            <p><strong>Advantage:</strong> Better performance than FIFO as it considers temporal locality.</p>
            <p><strong>Disadvantage:</strong> Requires additional overhead to track page usage history.</p>
            
            <h3>Optimal</h3>
            <p>Replaces the page that will not be used for the longest period of time in the future. This is a theoretical algorithm that requires future knowledge of page references.</p>
            <p><strong>Advantage:</strong> Provides the lowest possible page fault rate, serves as a benchmark.</p>
            <p><strong>Disadvantage:</strong> Not practically implementable in real systems as it requires knowledge of future references.</p>
            
            <h3>LFU (Least Frequently Used)</h3>
            <p>Replaces the page that has been used least frequently. It keeps a counter for each page and increments it on each access.</p>
            <p><strong>Advantage:</strong> Can perform better than LRU when access patterns have cyclical behavior.</p>
            <p><strong>Disadvantage:</strong> May keep pages with high historical frequency but no recent usage, leading to potential thrashing.</p>
            
            <h3>MFU (Most Frequently Used)</h3>
            <p>Replaces the page that has been used most frequently. Based on the logic that pages with high frequency counter values have completed their use and won't be used again soon.</p>
            <p><strong>Advantage:</strong> Can work well in certain specialized workloads.</p>
            <p><strong>Disadvantage:</strong> Generally performs worse than LFU and LRU in most common scenarios.</p>
            
            <h3>Additional Reference Bit Algorithm</h3>
            <p>An approximation of LRU that uses a reference bit and periodically shifts it into an 8-bit register to keep track of page usage history.</p>
            <p><strong>Advantage:</strong> More efficient than pure LRU while still capturing temporal locality patterns.</p>
            <p><strong>Disadvantage:</strong> Less accurate than true LRU but requires significantly less overhead.</p>
            
            <h3>Second Chance (Clock) Algorithm</h3>
            <p>A modification of FIFO that gives pages a "second chance" if they have been referenced since they were loaded. It uses a circular queue with a reference bit for each page.</p>
            <p><strong>Advantage:</strong> Simple to implement and better than FIFO by considering page usage.</p>
            <p><strong>Disadvantage:</strong> May require multiple passes through the queue to find a page for replacement.</p>
            
            <h3>Enhanced Second Chance Algorithm</h3>
            <p>An enhancement to the Second Chance algorithm that considers both the reference bit and the modify bit (dirty bit) to make better replacement decisions.</p>
            <p><strong>Advantage:</strong> Better performance by considering both usage and modification status.</p>
            <p><strong>Disadvantage:</strong> More complex implementation than Second Chance.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
           // DOM Elements
const algorithmSelect = document.getElementById('algorithm');
const framesInput = document.getElementById('frames');
const referenceStringInput = document.getElementById('reference-string');
const startButton = document.getElementById('start');
const resetButton = document.getElementById('reset');
const prevStepButton = document.getElementById('prev-step');
const nextStepButton = document.getElementById('next-step');
const autoPlayButton = document.getElementById('auto-play');
const referenceDisplay = document.getElementById('reference-display');
const framesDisplay = document.getElementById('frames-display');
const resultsDiv = document.getElementById('results');
const stepMessageDiv = document.getElementById('step-message');
const tabs = document.querySelectorAll('.tab');
const tabContents = document.querySelectorAll('.tab-content');

// Variables
let referenceString = [];
let frames = [];
let counters = {}; // For LFU and MFU
let referenceBits = {}; // For additional reference bit, second chance and enhanced second chance
let modifyBits = {}; // For enhanced second chance
let historyBits = {}; // For additional reference bit
let clockPointer = 0; // For second chance and enhanced second chance
let currentStep = -1;
let pageFaults = 0;
let pageHits = 0;
let history = [];
let autoPlayInterval;
let isAutoPlaying = false;

// Track page load order for FIFO algorithm
let pageLoadOrder = [];

// Initialize
function init() {
    algorithmSelect.disabled = false;
    framesInput.disabled = false;
    referenceStringInput.disabled = false;
    startButton.disabled = false;
    resetButton.disabled = true;
    prevStepButton.disabled = true;
    nextStepButton.disabled = true;
    autoPlayButton.disabled = true;
    
    referenceDisplay.innerHTML = '';
    framesDisplay.innerHTML = '';
    resultsDiv.innerHTML = '<p>Press "Start Visualization" to begin...</p>';
    stepMessageDiv.innerHTML = 'Press "Start Visualization" to begin...';
    
    referenceString = [];
    frames = [];
    counters = {};
    referenceBits = {};
    modifyBits = {};
    historyBits = {};
    clockPointer = 0;
    pageLoadOrder = [];
    currentStep = -1;
    pageFaults = 0;
    pageHits = 0;
    history = [];
    
    clearInterval(autoPlayInterval);
    isAutoPlaying = false;
    autoPlayButton.textContent = '⏵ Auto Play';
}

// Start visualization
startButton.addEventListener('click', function() {
    // Parse reference string
    referenceString = referenceStringInput.value
        .trim()
        .split(/\s+/)
        .map(n => parseInt(n));
    
    // Validate reference string
    if (referenceString.some(isNaN)) {
        alert('Invalid reference string. Please enter space-separated numbers.');
        return;
    }
    
    // Get number of frames
    const numFrames = parseInt(framesInput.value);
    if (isNaN(numFrames) || numFrames < 1 || numFrames > 10) {
        alert('Number of frames must be between 1 and 10.');
        return;
    }
    
    // Initialize frames
    frames = Array(numFrames).fill(null);
    
    // Initialize counters, reference bits, and modify bits for each possible page in reference string
    const uniquePages = new Set(referenceString);
    uniquePages.forEach(page => {
        counters[page] = 0;
        referenceBits[page] = 0;
        modifyBits[page] = 0;
        // Initialize history bits for additional reference bit algorithm
        historyBits[page] = 0; // 8-bit history (0-255)
    });
    
    // Reset page load order and clock pointer
    pageLoadOrder = [];
    clockPointer = 0;
    
    // Update UI
    algorithmSelect.disabled = true;
    framesInput.disabled = true;
    referenceStringInput.disabled = true;
    startButton.disabled = true;
    resetButton.disabled = false;
    nextStepButton.disabled = false;
    autoPlayButton.disabled = false;
    
    // Initialize visualization
    renderReferenceString();
    renderFrames();
    currentStep = -1;
    pageFaults = 0;
    pageHits = 0;
    history = [{ 
        frames: [...frames], 
        counters: {...counters},
        referenceBits: {...referenceBits},
        modifyBits: {...modifyBits},
        historyBits: {...historyBits},
        clockPointer: clockPointer,
        pageFault: false, 
        victim: null, 
        accessed: null,
        pageLoadOrder: [...pageLoadOrder],
        stepDescription: "Initial state: All frames are empty."
    }];
    
    stepMessageDiv.innerHTML = "Initial state: All frames are empty. Press 'Next Step' to begin.";
    updateResults();
});

// Reset visualization
resetButton.addEventListener('click', init);

// Next step
nextStepButton.addEventListener('click', nextStep);

// Previous step
prevStepButton.addEventListener('click', prevStep);

// Auto play
autoPlayButton.addEventListener('click', function() {
    if (isAutoPlaying) {
        clearInterval(autoPlayInterval);
        isAutoPlaying = false;
        autoPlayButton.innerHTML = '<span class="icon">⏵</span> Auto Play';
    } else {
        isAutoPlaying = true;
        autoPlayButton.innerHTML = '<span class="icon">⏸</span> Stop';
        autoPlayInterval = setInterval(() => {
            if (currentStep >= referenceString.length - 1) {
                clearInterval(autoPlayInterval);
                isAutoPlaying = false;
                autoPlayButton.innerHTML = '<span class="icon">⏵</span> Auto Play';
                return;
            }
            nextStep();
        }, 800);
    }
});

// Tab switching
tabs.forEach(tab => {
    tab.addEventListener('click', function() {
        // Remove active class from all tabs
        tabs.forEach(t => t.classList.remove('active'));
        // Add active class to clicked tab
        this.classList.add('active');
        
        // Hide all tab contents
        tabContents.forEach(content => content.style.display = 'none');
        // Show selected tab content
        document.getElementById(`${this.dataset.tab}-tab`).style.display = 'block';
    });
});

// Render reference string
function renderReferenceString() {
    referenceDisplay.innerHTML = '';
    
    referenceString.forEach((page, index) => {
        const cell = document.createElement('div');
        cell.className = 'reference-cell';
        cell.id = `ref-${index}`;
        cell.textContent = page;
        referenceDisplay.appendChild(cell);
    });
}

// Render memory frames with status indicators
function renderFrames() {
    framesDisplay.innerHTML = '';
    
    // Create initial column for frame numbers
    const frameNumberColumn = document.createElement('div');
    frameNumberColumn.className = 'frame-column';
    
    for (let i = 0; i < frames.length; i++) {
        const cell = document.createElement('div');
        cell.className = 'frame-cell';
        cell.textContent = `F${i}`;
        cell.style.fontWeight = 'bold';
        cell.style.backgroundColor = '#2d333b';
        frameNumberColumn.appendChild(cell);
    }
    
    framesDisplay.appendChild(frameNumberColumn);
    
    // Create a column for each step in history
    for (let i = 0; i <= currentStep + 1; i++) {
        if (i >= history.length) continue;
        
        const state = history[i];
        const column = document.createElement('div');
        column.className = 'frame-column';
        column.id = `step-${i}`;
        
        // For the current step, add a header indicator
        if (i === currentStep + 1 && i > 0) {
            const stepHeader = document.createElement('div');
            if (state.pageFault) {
                stepHeader.className = 'status-indicator fault';
                stepHeader.textContent = 'PAGE FAULT';
            } else if (state.accessed !== null) {
                stepHeader.className = 'status-indicator hit';
                stepHeader.textContent = 'PAGE HIT';
            }
            column.appendChild(stepHeader);
        }
        
        for (let j = 0; j < frames.length; j++) {
            const cell = document.createElement('div');
            cell.className = 'frame-cell';
            
            // Set content
            if (state.frames[j] !== null) {
                // Show page number with reference bit (for Second Chance)
                if (['second-chance', 'enhanced-second-chance'].includes(algorithmSelect.value)) {
                    const page = state.frames[j];
                    // Create superscript for reference bit
                    cell.textContent = page;
                    const superscript = document.createElement('sub');
                    superscript.textContent = state.referenceBits[page];
                    superscript.style.fontSize = '65%';
                    superscript.style.marginLeft = '1px';
                    cell.appendChild(superscript);
                } else {
                    cell.textContent = state.frames[j];
                }
                
                // For enhanced second chance, show class (R,M)
                if (algorithmSelect.value === 'enhanced-second-chance') {
                    const page = state.frames[j];
                    if (page !== null) {
                        const e2cInfo = document.createElement('div');
                        e2cInfo.className = 'e2c-info';
                        e2cInfo.textContent = `${state.referenceBits[page]},${state.modifyBits[page]}`;
                        cell.appendChild(e2cInfo);
                    }
                }
                // // Highlight current clock pointer for second chance algorithms
                // if (['second-chance', 'enhanced-second-chance'].includes(algorithmSelect.value)) {
                //     if (j === state.clockPointer) {
                //         cell.style.boxShadow = 'inset 0 0 0 2px #f39c12';
                //     }
                // }
                
                // Add badges for special states
                if (i === currentStep + 1) {
                    // Add victim badge
                    if (state.victim === state.frames[j]) {
                        cell.classList.add('victim');
                        const victimBadge = document.createElement('span');
                        victimBadge.className = 'badge victim';
                        victimBadge.textContent = 'out';
                        cell.appendChild(victimBadge);
                    }
                    
                    // Add hit/fault badge
                    if (state.accessed === state.frames[j]) {
                        if (state.pageFault) {
                            cell.classList.add('page-fault');
                            const faultBadge = document.createElement('span');
                            faultBadge.className = 'badge fault';
                            faultBadge.textContent = 'new';
                            cell.appendChild(faultBadge);
                        } else {
                            cell.classList.add('page-hit');
                            const hitBadge = document.createElement('span');
                            hitBadge.className = 'badge hit';
                            hitBadge.textContent = 'hit';
                            cell.appendChild(hitBadge);
                        }
                    }
                }
            }
            
            column.appendChild(cell);
        }
        
        framesDisplay.appendChild(column);
    }
    
    // Scroll to right to see latest step
    framesDisplay.scrollLeft = framesDisplay.scrollWidth;
}

// Next step in visualization
function nextStep() {
    if (currentStep >= referenceString.length - 1) return;
    
    currentStep++;
    
    // Highlight current reference
    const prevRef = document.getElementById(`ref-${currentStep - 1}`);
    if (prevRef) prevRef.classList.remove('current');
    
    const currRef = document.getElementById(`ref-${currentStep}`);
    if (currRef) {
        currRef.classList.add('current');
        currRef.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
    }
    
    const pageToAccess = referenceString[currentStep];
    let pageFault = false;
    let victimPage = null;
    let stepDescription = '';
    
    // Check if page is already in memory
    const pageIndex = frames.indexOf(pageToAccess);
    
    if (pageIndex !== -1) {
        // Page hit
        pageHits++;
        stepDescription = `Page ${pageToAccess} is already in frame F${pageIndex}. Page HIT.`;
        
        // Update counters for LFU/MFU
        counters[pageToAccess]++;
        
        // Set reference bit for algorithms that use it
        referenceBits[pageToAccess] = 1;
        
        // For additional reference bit algorithm, update history
        if (algorithmSelect.value === 'additional-reference-bit') {
            historyBits[pageToAccess] = (historyBits[pageToAccess] >> 1) | 128; // Set MSB and shift right
        }
        
        // Randomly set modify bit sometimes for enhanced second chance (just for demonstration)
        if (algorithmSelect.value === 'enhanced-second-chance' && Math.random() > 0.7) {
            modifyBits[pageToAccess] = 1;
        }
    } else {
        // Page fault
        pageFault = true;
        pageFaults++;
        
        // Check if there's an empty frame
        const emptyFrameIndex = frames.indexOf(null);
        
        if (emptyFrameIndex !== -1) {
            // Place page in empty frame
            frames[emptyFrameIndex] = pageToAccess;
            pageLoadOrder.push(pageToAccess);
            stepDescription = `Page ${pageToAccess} loaded into empty frame F${emptyFrameIndex}. Page FAULT.`;
            
            // Initialize counter, reference bit, and modify bit
            counters[pageToAccess] = 1;
            referenceBits[pageToAccess] = 0;
            modifyBits[pageToAccess] = 0;
            
            // For additional reference bit algorithm, update history
            if (algorithmSelect.value === 'additional-reference-bit') {
                historyBits[pageToAccess] = 128; // Set only MSB
            }
        } else {
            // Need to replace a page
            const algorithm = algorithmSelect.value;
            let victimIndex = 0;
            
            // Different page replacement algorithms
            switch (algorithm) {
                case 'fifo':
                    // Get the oldest page (first in)
                    const oldestPage = pageLoadOrder[0];
                    victimIndex = frames.indexOf(oldestPage);
                    victimPage = frames[victimIndex];
                    
                    // Update page load order
                    pageLoadOrder.shift();
                    pageLoadOrder.push(pageToAccess);
                    
                    stepDescription = `Using FIFO: Page ${victimPage} was loaded first, replacing it with Page ${pageToAccess} in frame F${victimIndex}. Page FAULT.`;
                    break;
                    
                    case 'lru':
    // Find the least recently used page by checking when each frame was last accessed
    let leastRecentUsed = Infinity;
    let lruIndex = 0;
    
    // For each frame, find when it was last accessed
    for (let i = 0; i < frames.length; i++) {
        const page = frames[i];
        let lastUsed = -1;
        
        // Look backward through reference string to find when this page was last accessed
        for (let j = currentStep - 1; j >= 0; j--) {
            if (referenceString[j] === page) {
                lastUsed = j;
                break;
            }
        }
        
        // If this page was used less recently than our current LRU page, update
        if (lastUsed < leastRecentUsed) {
            leastRecentUsed = lastUsed;
            lruIndex = i;
        }
    }
    
    victimIndex = lruIndex;
    victimPage = frames[victimIndex];
    
    stepDescription = `Using LRU: Page ${victimPage} was least recently used, replacing it with Page ${pageToAccess} in frame F${victimIndex}. Page FAULT.`;
    break;
                    
                case 'optimal':
                    // Find the page that won't be used for the longest time in the future
                    let farthestIndex = -1;
                    let farthestPage = null;
                    let farthestDistance = -1;
                    
                    for (let i = 0; i < frames.length; i++) {
                        const page = frames[i];
                        const futureUse = referenceString.slice(currentStep + 1).indexOf(page);
                        
                        // If page won't be used again, select it
                        if (futureUse === -1) {
                            farthestIndex = i;
                            farthestPage = page;
                            break;
                        }
                        
                        // Otherwise, find the page used farthest in the future
                        if (futureUse > farthestDistance) {
                            farthestDistance = futureUse;
                            farthestIndex = i;
                            farthestPage = page;
                        }
                    }
                    
                    victimIndex = farthestIndex;
                    victimPage = frames[victimIndex];
                    
                    stepDescription = `Using Optimal: Page ${victimPage} won't be used for the longest time, replacing it with Page ${pageToAccess} in frame F${victimIndex}. Page FAULT.`;
                    break;
                    
                case 'lfu':
                    // Find the least frequently used page
                    let minCount = Infinity;
                    let lfuIndex = 0;
                    
                    for (let i = 0; i < frames.length; i++) {
                        const page = frames[i];
                        if (counters[page] < minCount) {
                            minCount = counters[page];
                            lfuIndex = i;
                        }
                    }
                    
                    victimIndex = lfuIndex;
                    victimPage = frames[victimIndex];
                    
                    // Reset counter for the new page
                    counters[pageToAccess] = 1;
                    referenceBits[pageToAccess] = 1;
                    modifyBits[pageToAccess] = 0;
                    
                    stepDescription = `Using LFU: Page ${victimPage} was used ${counters[victimPage]} times (least frequent), replacing it with Page ${pageToAccess} in frame F${victimIndex}. Page FAULT.`;
                    break;
                    
                case 'mfu':
                    // Find the most frequently used page
                    let maxCount = -1;
                    let mfuIndex = 0;
                    
                    for (let i = 0; i < frames.length; i++) {
                        const page = frames[i];
                        if (counters[page] > maxCount) {
                            maxCount = counters[page];
                            mfuIndex = i;
                        }
                    }
                    
                    victimIndex = mfuIndex;
                    victimPage = frames[victimIndex];
                    
                    // Reset counter for the new page
                    counters[pageToAccess] = 1;
                    referenceBits[pageToAccess] = 1;
                    modifyBits[pageToAccess] = 0;
                    
                    stepDescription = `Using MFU: Page ${victimPage} was used ${counters[victimPage]} times (most frequent), replacing it with Page ${pageToAccess} in frame F${victimIndex}. Page FAULT.`;
                    break;
                    
                case 'additional-reference-bit':
                    // Find the page with the lowest history value
                    let minHistory = Infinity;
                    let minHistoryIndex = 0;
                    
                    for (let i = 0; i < frames.length; i++) {
                        const page = frames[i];
                        if (historyBits[page] < minHistory) {
                            minHistory = historyBits[page];
                            minHistoryIndex = i;
                        }
                    }
                    
                    victimIndex = minHistoryIndex;
                    victimPage = frames[victimIndex];
                    
                    // Set history for the new page
                    historyBits[pageToAccess] = 128; // Set only MSB
                    
                    stepDescription = `Using Additional Reference Bit: Page ${victimPage} had lowest history value ${minHistory.toString(2).padStart(8, '0')}, replacing it with Page ${pageToAccess} in frame F${victimIndex}. Page FAULT.`;
                    break;
                    
                case 'second-chance':
                    // Start from the clock pointer and find the first page with reference bit = 0
                    let found = false;
                    let scStartPointer = clockPointer;
                    let scIterations = 0;
                    
                    while (!found && scIterations < frames.length * 2) {
                        const page = frames[clockPointer];
                        
                        if (referenceBits[page] === 0) {
                            found = true;
                            victimIndex = clockPointer;
                            victimPage = page;
                        } else {
                            // Give second chance by clearing reference bit
                            referenceBits[page] = 0;
                            // Move clock pointer
                            clockPointer = (clockPointer + 1) % frames.length;
                        }
                        
                        scIterations++;
                    }
                    
                    // If no page with reference bit 0 found, use the current pointer
                    if (!found) {
                        victimIndex = clockPointer;
                        victimPage = frames[clockPointer];
                    }
                    
                    // Set reference bit for new page
                    referenceBits[pageToAccess] = 1;
                    
                    // Move clock pointer to next position
                    clockPointer = (victimIndex + 1) % frames.length;
                    
                    stepDescription = `Using Second Chance: Clock pointer at F${victimIndex}, Page ${victimPage} selected for replacement with Page ${pageToAccess}. Page FAULT.`;
                    break;
                    case 'enhanced-second-chance':
    // Implementation of Enhanced Second Chance algorithm
    // It uses both reference (R) and modify (M) bits to create 4 classes:
    // (0,0) - Not recently used, not modified - first to replace
    // (0,1) - Not recently used, modified - second to replace
    // (1,0) - Recently used, not modified - third to replace
    // (1,1) - Recently used, modified - last to replace
    
    // First, set reference bit for the current page access
    referenceBits[pageToAccess] = 1;
    
    // Track candidates for each class
    let candidates = [[], [], [], []];
    let victimR = 0;
    let victimM = 0;
    
    // First scan: categorize all pages into their classes
    for (let i = 0; i < frames.length; i++) {
        const page = frames[i];
        const classIndex = referenceBits[page] * 2 + modifyBits[page];
        candidates[classIndex].push({ page, index: i });
    }
    
    // Find the lowest class that has candidates
    let selectedClass = -1;
    for (let i = 0; i < 4; i++) {
        if (candidates[i].length > 0) {
            selectedClass = i;
            break;
        }
    }
    
    // If no class 0 candidates found, clear reference bits and re-categorize
    if (selectedClass > 0) {
        // Clear reference bits for all pages (not just class 2 and 3)
        for (let i = 0; i < frames.length; i++) {
            const page = frames[i];
            referenceBits[page] = 0;
        }
        
        // Re-categorize after clearing reference bits
        candidates = [[], [], [], []];
        for (let i = 0; i < frames.length; i++) {
            const page = frames[i];
            const classIndex = referenceBits[page] * 2 + modifyBits[page];
            candidates[classIndex].push({ page, index: i });
        }
        
        // Find lowest class again
        selectedClass = -1;
        for (let i = 0; i < 4; i++) {
            if (candidates[i].length > 0) {
                selectedClass = i;
                break;
            }
        }
    }
    
    // Use clock algorithm within the selected class
    let victimFound = false;
    let iterations = 0;
    const startPointer = clockPointer;
    
    while (!victimFound && iterations < frames.length) {
        const currentPage = frames[clockPointer];
        const currentClass = referenceBits[currentPage] * 2 + modifyBits[currentPage];
        
        if (currentClass === selectedClass) {
            victimIndex = clockPointer;
            victimPage = currentPage;
            victimR = referenceBits[currentPage];
            victimM = modifyBits[currentPage];
            victimFound = true;
            break;
        }
        
        clockPointer = (clockPointer + 1) % frames.length;
        iterations++;
        
        if (clockPointer === startPointer && !victimFound) {
            if (candidates[selectedClass].length > 0) {
                victimIndex = candidates[selectedClass][0].index;
                victimPage = candidates[selectedClass][0].page;
                victimR = referenceBits[victimPage];
                victimM = modifyBits[victimPage];
                victimFound = true;
            }
        }
    }
    
    if (!victimFound) {
        victimIndex = 0;
        victimPage = frames[0];
        victimR = referenceBits[victimPage];
        victimM = modifyBits[victimPage];
    }
    
    // Set reference bit and modify bit for new page
    referenceBits[pageToAccess] = 1;  // New pages are recently used
    modifyBits[pageToAccess] = 0;     // Initially not modified
    
    // Move clock pointer to next position
    clockPointer = (victimIndex + 1) % frames.length;
    
    // Use the stored R and M values for the victim page for the message
    const victimClass = `(${victimR},${victimM})`;
    const classNames = [
        "lowest priority (not recently used, not modified)", 
        "second priority (not recently used, modified)",
        "third priority (recently used, not modified)",
        "highest priority (recently used, modified)"
    ];
    const classIndex = victimR * 2 + victimM;
    
    stepDescription = `Using Enhanced Second Chance: Page ${victimPage} with class ${victimClass} (${classNames[classIndex]}) selected for replacement with Page ${pageToAccess}. Page FAULT.`;
    break;
                
                default:
                    // Default to FIFO
                    victimIndex = 0;
                    victimPage = frames[0];
                    stepDescription = `Using default algorithm: Replacing Page ${victimPage} with Page ${pageToAccess} in frame F${victimIndex}. Page FAULT.`;
            }
            
            // Replace the victim page
            frames[victimIndex] = pageToAccess;
        }
    }
    
    // Save the current state to history
    history.push({
        frames: [...frames],
        counters: {...counters},
        referenceBits: {...referenceBits},
        modifyBits: {...modifyBits},
        historyBits: {...historyBits},
        clockPointer: clockPointer,
        pageFault: pageFault,
        victim: victimPage,
        accessed: pageToAccess,
        pageLoadOrder: [...pageLoadOrder],
        stepDescription: stepDescription
    });
    
    // Update UI
    stepMessageDiv.innerHTML = stepDescription;
    renderFrames();
    updateResults();
    
    // Enable/disable buttons
    prevStepButton.disabled = false;
    nextStepButton.disabled = currentStep >= referenceString.length - 1;
}

// Previous step in visualization
function prevStep() {
    if (currentStep < 0) return;
    
    // Remove current step from history
    if (history.length > 1) {
        history.pop();
    }
    
    // Get previous state
    const prevState = history[history.length - 1];
    frames = [...prevState.frames];
    counters = {...prevState.counters};
    referenceBits = {...prevState.referenceBits};
    modifyBits = {...prevState.modifyBits};
    historyBits = {...prevState.historyBits};
    clockPointer = prevState.clockPointer;
    pageLoadOrder = [...prevState.pageLoadOrder];
    
    // If it was a page fault, decrement counter
    if (currentStep >= 0 && prevState.pageFault) {
        pageFaults--;
    } else if (currentStep >= 0 && !prevState.pageFault && prevState.accessed !== null) {
        pageHits--;
    }
    
    currentStep--;
    
    // Update reference highlighting
    const currRef = document.getElementById(`ref-${currentStep}`);
    if (currRef) {
        document.querySelectorAll('.reference-cell').forEach(el => el.classList.remove('current'));
        currRef.classList.add('current');
        currRef.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
    }
    
    // Update UI
    stepMessageDiv.innerHTML = prevState.stepDescription;
    renderFrames();
    updateResults();
    
    // Enable/disable buttons
    nextStepButton.disabled = false;
    prevStepButton.disabled = currentStep < 0;
}

// Update results display
function updateResults() {
    if (currentStep < 0) {
        resultsDiv.innerHTML = '<p>Press "Start Visualization" to begin...</p>';
        return;
    }
    
    const total = currentStep + 1;
    const faultRate = (pageFaults / total * 100).toFixed(2);
    const hitRate = (pageHits / total * 100).toFixed(2);
    
    resultsDiv.innerHTML = `
        <p><strong>Pages Accessed:</strong> ${total}</p>
        <p><strong>Page Faults:</strong> ${pageFaults} (${faultRate}%)</p>
        <p><strong>Page Hits:</strong> ${pageHits} (${hitRate}%)</p>
    `;
}

// Initialize the app
init();
        });
    </script>
</body>
</html>
